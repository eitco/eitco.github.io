

The interface `SearchService` contains three entry points using a Fluent API:

.Fluent API entry points
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=fluent]
----

The first method `all()` simply returns all elements - <<_paging, paging>> still needs to be defined.

The second method `where()` begins the fluent api for creating a condition by returning a `ConditionBuilder`. The resulting search will return only elements that meet the given condition. <<_paging,Paging>> will be need to be defined.

The third method `existsWhere()` also starts the fluent api for creating a condition. As opposed to `where()`, it will create a query that determines whether at least one element that meets the condition exists.

=== Conditions

The simplest conditions are boolean literals. Whenever you have a `ConditionBuilder` at hand you can simply call `alwaysTrue()` or `alwaysFalse()` to create a condition that always respectively never holds. Thus, the following code would be equivalent to simply calling `all()`:

.Simple fluent API call
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=boolean-literal]
----


==== Comparisons and Values

The first less simple conditions are comparison. EQL allows values to be compared with the operators `=`, `≠`, `<`, `≤`, `>` and `≥`. These can be created using the methods `equalTo()`, `notEqual()`, `lessThan()`, `lessEqual()`, `greaterThan()` and `greaterEqual()`. These are found in the class `PredicateInfixBuilder` for reference. There are some more specific comparison operators, but we will keep it simple for now.

Values can be defined using the method `value(Object)`. The following code would still be equivalent to simply calling `all()`

.Simple comparison
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=comparison]
----

==== Context References

In order for conditions to actually do something we need to reference properties of the objects we search for. What a property is and which properties exist depends on the search implementation. When using the in-memory search on a list of java objects for example, every field of the class of the objects searched for would be able to be referenced. In a sql search on a table the fields of the table could be referenced.

A context reference is a list of strings defining a path to the property referenced. For in-memory searches this allows to evaluate properties by reflection and even reference properties of objects that are a field of the objects searched for themselves. For sql searches this allows to specify alias prefixes and the like.

.Condition using a context reference
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=context-reference]
----

The example above would result - in case of a sql search - in a sql `WHERE my.property < 400`.
In case of an in-memory search it would assume a class like the following:

.A simple class that can be searched with the statement above
[source,java]
----
public class Outer {

    private Inner my;

    public static class Inner {

        private int property;

        // ...
        // other properties, getters, setters, etc
    }
    // ...
    // other properties, getters, setters, etc
}
----

The statement given defines a condition that holds for any instance of `Outer` whose field `my` holds an instance of `Inner` whose field `property` is less than 400.

===== Ending a condition with `holds()`

After you specify the condition call `holds()` to specify <<_paging,paging>>:

.A simple complete condition ready for paging
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=holds]
----

===== Boolean Operators

Comparisons can be linked to other comparisons with boolean operators. After a comparison one can call `and()` or `or()` and then specify another condition in order to create a condition that holds if and only if both conditions (respectively at least one of the conditions) hold(s).

.Conditions linked with `and()`
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=boolean-operator]
----

This way you can specify very complex queries:

.Complex query using many `and()` and `or()` calls
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=complex]
----

This rises the question, in which order the `and`/`or` links are evaluated. It is done as most conventions specify: `and()` links are evaluated before `or()` links. Thus, the condition above would result in a sql clause equivalent to the following:

.An SQL `WHERE` clause with explicit braces
[source,sql]
----
WHERE
    ("my"."property" < 400 AND 'my-value' != "other-property") OR
    ("field" != 'value') OR
    ("my"."property" >= 600 AND "field" = 'more')
----

Should one need to set braces explicitly one can use the `and(Expression<Boolean>)` and `or(Expression<Boolean>)` methods.

.Setting braces with `and(Expression<Boolean>)`
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=braces]
----

The example above would create in the following sql clause

.An SQL `WHERE` clause with explicit braces
[source,sql]
----
WHERE
    "my"."property" < 400 AND (
        ("field" != 'value-1') OR
        ("field" != 'value-2') OR
        ("field" != 'value-3')
    )
----

Of course EQL also supports boolean `not`. Before any EQL statements that result in a condition you can simply call `not()` to negate the given condition:

.Negating a condition with `not()`
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=not]
----

=== Paging

As soon as you finish a condition with <<_ending_a_condition_with_holds, `holds()`>> or if you just called `SearchService.all()` you will need to specify paging. The results of searches on huge amount of data can be huge as well, so `SearchService` supports paging that is returning only a part of the result.

Of course, if you know that the result is that huge, you can simply skip paging by calling `unpaged()` which will simply return all elements that satisfy the given condition.

.An unpaged query
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=unpaged]
----

Otherwise, you will need to page the result. Paging is underspecified without ordering, so at first you will need to define an order with `order()`. You can rely on the implicit order of the search implementation, by just skipping to the next step. Otherwise, you can give fields to order by ascendingly and descendingly by calling `ascendingBy(String...)` and `descendingBy(String...)`. The strings given to these methods hold the names of the properties that should be ordered by just like <<_context_references, context references>>. Both methods can be called several times.

After the order is specified the page can be defined. It consists of its position in the complete result and its size. The position is given with the method `from(int)`. After that the size can either be specified by `pageSize(int)` or by `to(int)`. While the first method directly sets the size of the page, the second specifies the index of the last element. Thus calling `from(n).pageSize(m)` would be equivalent to `from(n).to(n + m)`. Specifying the page can also be omitted, resulting in an unpaged but ordered result.

.A completely specified paging
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=paged]
----

<1> The result should be ordered ...
<2> ... primarily ascending by the property "my.property" ...
<3> ... if my.property equals for two elements, those should be ordered descending by the property "field"
<4> The result should not contain the first 10 elements ...
<5> ... and only the 400 that follow (or less if the result does not contain that many elements)

=== Finishing a Query

There are several ways to finish a query. The completely specified paged example is one. That call results in an instance of `Page<T>`, which contains a member `result` of Type `List<T>` that contains the elements queried for, in the order specified. The page also contains a page definition, which is the one that was given so that the result also contains its 'context'. Additionally, the complete count is returned. This is not necessarily the size of the result, but it is what its size would be if the query was unpaged.

Above we saw a call to `unpaged()` which completely omitted paging. In this case the query is executed with this call and a list with the result is returned. There is no need to return a page in this case, since the call is unpaged.

A common use case are queries whose condition identifies a unique feature of the elements so that the query has at most one result element. Searches for a given id are an example. In this case the method `uniqueResult()` can be called, where `unpaged()` could be called:

.A query by id
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=unique]
----

This method returns an `Optional<Type>` which is empty if no element matches the given condition, and the unique element that matches the condition otherwise. If several elements match the condition, an exception is thrown. In this case no paging can be specified.

Another way to finish a query is to call `count()`. This also omits paging. However, it does not return a result list only the number of elements that match the given condition.

.A query that only counts the matching elements
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=count]
----

==== Iterating the Result Set

Using the method `iterable(int)` one can create an iterable of the result set. The given integer sets the page size. The resulting iterable will iterate over the complete result set, but obtain the results in pages of the given size.

.The result as iterable
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=iterable]
----
The code above will iterate over every element that does not have the value `"value-4"` in its field `field` in descending order by that field and prints its string representation to stdout. Every 500 result elements it will retrieve the next 500 elements and go on iterating, until none else are left.

The API can also be used to create a stream:

.The result as stream
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=stream]
----
This will create a stream of all the elements, that do not have the value `"value-4"` in its field `field` (in descending order by that field). When items of this stream are actually retrieved, they will be in chunks of the size 500.

Thus, the code below is equivalent to the iterating example, above.

.Iterating over a retrieved stream
[source,java]
----
include::../../../../api/src/test/java/de/eitco/commons/query/language/api/test/sample/Fluent.java[tag=stream-iterate]
----
